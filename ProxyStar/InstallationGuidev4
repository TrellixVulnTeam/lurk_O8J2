These are the steps to get the whole simulation going:

- Prepare 3 VM using ubuntu: Server, Proxy, Client

Prepare the Server:

- In your home directory create: ~/gopath/src/github.com/letsencrypt/boulder and place all the files there.(the files that are currently in https://github.com/diegoDAguilar/myBoulder. NOTE: When you have everything copied you should't have a myBoulder file,
everything must be inside letsencrypt/boulder/, if you do "ls" there it must return the files that are currently under myBoulder/boulder)
- Install GO and set environment variable PATH to /usr/local/go/bin
- Fully install Docker and Docker-Compose: https://docs.docker.com/compose/install/ just follow the steps and test that the hello-world image works. I m using version 17.03.1-ce for Docker and version 1.12.0 for Docker-Compose.
- Go to boulder/test/config/va.json and make sure your port config in va is : 80, 5001, 5001.
- Go to boulder/docker-compose.yml and check that in the list of ports you have 80:80 and 443:443 (these 2 steps should be done if you download my repo)
- Change in boulder/docker-compose.yml the FAKE_DNS field to the IP of your server.
- Set ufw status to inactive: sudo ufw disable
- See your iptables: sudo iptables -L and set CHAIN FORWARD policy to accept if it is currently drop: sudo iptables -P FORWARD ACCEPT
- Make sure you can reach the other machines by pinging them and change the route table if needed.
- Open /etc/hosts and add:

	172.17.0.4      acme-v01.api.letsencrypt.org boulder //this is the local IP of Boulder at least in my machine
														//If using "ifconfig" in the server returns you an interface
														//called docker0 172.17.0.1, then it should be the same.
	"proxy's IP"  bye.com //this is the web hosted for the example

Prepare the Proxy: 

- Go sudo -i and place there all the files in https://github.com/diegoDAguilar/MyProxy so that the end directory of files such as proxySTAR.go and exeAutoRenew.sh is /root/
- Go to certbot/ and type: source ./venv/bin/activate (You always need this ON if you exit the vm)
- Declare global environment:  export SERVER=http://172.17.0.4:4000/directory    (this is where Boulder is listening)
- Install Go, my version is : go1.8.2 linux/amd64
- Set GOPATH to /root/gopath and PATH to /root/go/bin
- Make the ping and iptables checks.
- Host some website, the way I did it is using Apache (e.g. bye.com):
	1. Place an html file in /var/www/bye.com/html/bye.html
	2. Go to /etc/apache2/sites-available and copy a file called 000-default.conf in the same directory as bye.com.conf
	3. Open this new file and make sure virtualhost is set to 80 and the rest of the fields look like this (although the first field isn't important for now so leave it out if you want): 
		ServerAdmin info@bye.com
        ServerName bye.com 
        ServerAlias www.bye.com
        DocumentRoot /var/www/bye.com/html
    4. In sites-available run this commands: 
    	sudo a2ensite bye.com.conf
    	sudo a2dissite 000-default.conf
    	sudo service apache2 restart
- Now prepare the proxy for http challenge by creating 2 directories so the result is like this:  in /var/www/bye.com/html/.well-known/acme-challenge
- Now you have to make sure that you can access the directory acme-challenge so place a hello.html file there and try to reach it with curl from the server, if it works feel free to delete it.
For the simulation to work, you also need to generate a certificate using openSSL so that proxy and client can use https.
-Give execution permisions to all bash scripts like this: sudo +x chmod *.sh

HOW TO RUN A FULL SIMULATION

0. IMPORTANT: If you are restarting the proxy then the file starCerts must be deleted as well as its contents or at least the file links kept right under it. 
1. In the server go to ~/gopath/src/github.com/letsencrypt/boulder
2. Run these 2 commands:
	docker-compose build
	docker-compose up

	And wait until it says press ^C to stop

3. Go to proxy as superuser, type in ~/certbot# source ./venv/bin/activate
4. Then: export SERVER=http://172.17.0.4:4000/directory
5. Now you are ready to go: go run proxySTAR.go
You will see a message: "Executing" (NOTE: If some pop up asks you to enter an email to create an account just invent one. If some weird error happens then ^C to stop proxySTAR.go, go to certbot/certbot and type: "python main.py register" then you can repeat step 5)
6. Go to client VM and POST at https://certProxy:443/star/registration (Dont forget to add certProxy to your /etc/hosts or type proxy's IP instead of the keyword).
	For now the full command looks like this:
		curl --cacert /usr/share/ca-certificates/mozilla/server.crt \
		-H "Content-Type: application/json" -X POST -d \
		@fullCSR2 https://certProxy:443/star/registration

		*server.crt is an openssl cert I generated so proxy and client can use https
		*fullCSR2 is a textfile that contains a basic CSR with the domain name as SN field
		(subject name) plus lifetime and validity in format: 
		{"csr":"----BEGIN CERT---\ngfdgfhdgjfh\nfdfjsdkfsd...--END CERT----","lifetime":365, "validity":24}

7. The client will get the uri when it is ready using: curl http://192.168.122.125:9999/completionURL 
7.5 The uri will be a uuid4
8. The client can retrieve the cert by using:
	curl http://192.168.122.125:9500/586c4b2d-ad4d-4523-9c6b-934470be1c56

	*586c...is this example's certificate URI


9. To try the renewal yourself, first check with "crontab -l" that the renewal has been added, you can set the time to current time editing the crontable with "crontab -e" or try the execution just now if you go to script exeAutoRenew.sh, comment the if-else sentences so that the else body remains as the only option and then execute "sh exeAutoRenew bye.com 05 05 $cronTaskID" replacing $cronTaskID with the id of the certificate, for example 0 or 10 (the number are assigned in order, p.e. first cert is 0, second is 1...), you can check the cronTaskID of a certificate in /starCerts/links

10. Then client can retrieve the new certificate from the same place: 
	curl http://192.168.122.125:9500/586c4b2d-ad4d-4523-9c6b-934470be1c56

STATUS

After some time client will receive a message to do a GET to some direction, when the certificate is ready it will be there so the client can download it, if not it returns "in progress".
The proxy will take care of the renovations adding a cronjob that will ask for new issuances.
Client can get the renewed certificates from the same source just by doing: 
